
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


def palindrome(start_node):
    if start_node == None or start_node.next == None:
        return True
    print("1")
    print_linkedlist(start_node)
    prev = ListNode(start_node.val, start_node.next)
    nxt = start_node.next
    
    # fast nxt & slow nxt
    while nxt:
        prev = prev.next
        nxt = nxt.next
        if nxt:
            nxt = nxt.next
    print("2")
    print_linkedlist(start_node)

    # reverse 
    mid = ListNode(prev.val, prev.next)
    prev_rev = None
    while mid: # middle node
        temp = mid.next
        mid.next = prev_rev
        prev_rev = mid
        mid = temp
    print("3")
    print_linkedlist(start_node)

    node = ListNode(start_node.val, start_node.next)
    while prev_rev:
        if node.val != prev_rev.val:
            return False
        node = node.next
        prev_rev = prev_rev.next
    print("4")
    print_linkedlist(start_node)

    return True


def print_linkedlist(start_node):
    while (True):
        print(start_node.val, '->', end=' ')
        start_node = start_node.next
        if ( start_node == None): 
            print('none')
            break

def get_length(s):
    length = 0
    while (True):
        if s == None: break
        length += 1
        s = s.next
    return length


def issub(s, t):
    # t in s?
    st = t    
    while (s and t):
        if s.val != t.val:
            s = s.next
            t = st
        else:
            s = s.next
            t = t.next

    if t == None:
        return True
    else:
        return False

    
def slicing(start_node, start, length):
    while start :
        if not start_node:
            return None  
        start_node = start_node.next
        start -= 1

    if not start_node:
        return None

    st = ListNode(start_node.val)
    current = st
    length -= 1
    while length > 0 and start_node.next:  
        start_node = start_node.next
        nxt = ListNode(start_node.val)
        current.next = nxt
        current = nxt  
        length -= 1
        
    return st


def maxpalindrome(s):
    length = get_length(s)
    window = length
    while window:
        for i in range(length - window + 1):
            sub = slicing(s, i, window)
            print('bf')
            print_linkedlist(sub)

            print(window, palindrome(sub))
            print('af')
            print_linkedlist(sub)
            
            if palindrome(sub): 
                print(';')
                return sub
        window -= 1

    return None


node5 = ListNode(1)
node4 = ListNode(2, node5)
node3 = ListNode(3, node4)
node2 = ListNode(3, node3)
node1 = ListNode(2, node2)


# node2_ = ListNode(1)
# node1_ = ListNode(2, node2_)

# print_linkedlist(node1)
# print_linkedlist(node1_)

# issu = issub(node1, node1_)
# print(issu)
# sub = slicing(node1, 1, 3)
# print_linkedlist(sub)

result = maxpalindrome(node1)
print_linkedlist(result)